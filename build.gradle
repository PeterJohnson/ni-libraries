plugins {
    id 'base'
    id 'maven-publish'
    id "com.jfrog.artifactory" version "4.9.8"
}

publishing {
  repositories {
    if (project.hasProperty('releaseRepoPublish')) {
      maven {
        url "${System.getProperty('user.home')}/releases/maven/release"
      }
    } else {
      maven {
        url "${System.getProperty('user.home')}/releases/maven/development"
      }
    }
  }
}

if (System.getenv()['RUN_AZURE_ARTIFACTORY_RELEASE'] != null) {
  artifactory {
    contextUrl = 'https://frcmaven.wpi.edu/artifactory' // base artifactory url
    publish {
      repository {
        if (project.hasProperty('releaseRepoPublish')) {
          repoKey = 'release'
        } else {
          repoKey = 'development'
        }
        username = System.getenv()['ARTIFACTORY_PUBLISH_USERNAME']
        password = System.getenv()['ARTIFACTORY_PUBLISH_PASSWORD']
        maven = true
      }
      defaults {
          publications ('chipobject', 'netcomm')
      }
    }
  }
  publish.dependsOn artifactoryPublish
}


def allOutputsFolder = file("$buildDir/allOutputs")

if (project.hasProperty('releaseRepoPublish')) {
  allOutputsFolder = file("$buildDir/allOutputsRelease")
}

task copyAllOutputs(type: Copy) {
    destinationDir allOutputsFolder
}

build.dependsOn copyAllOutputs

ext.addTaskToCopyAllOutputs = { task ->
    copyAllOutputs.dependsOn task
    copyAllOutputs.inputs.file task.archivePath
    copyAllOutputs.from task.archivePath
}

def pubVersion = '2020.4.1'

def baseArtifactId = 'chipobject'
def artifactGroupId = 'edu.wpi.first.ni-libraries'
def zipBaseName = '_GROUP_edu_wpi_first_ni-libraries_ID_chipobject_CLS'

def netcommBaseArtifactId = 'netcomm'
def netcommZipBaseName = '_GROUP_edu_wpi_first_ni-libraries_ID_netcomm_CLS'

def outputsFolder = file("$project.buildDir/outputs")

def versionFile = file("$outputsFolder/version.txt")

task outputVersions() {
    description = 'Prints the versions of this to a file for use by the downstream packaging project'
    group = 'Build'
    outputs.files(versionFile)

    doFirst {
        buildDir.mkdir()
        outputsFolder.mkdir()
    }

    doLast {
        versionFile.write pubVersion
    }
}

build.dependsOn outputVersions
copyAllOutputs.dependsOn outputVersions
copyAllOutputs.inputs.file versionFile
copyAllOutputs.from versionFile

task libZip(type: Zip) {
    destinationDir = outputsFolder
    baseName = zipBaseName
    classifier = "linuxathena"

    from('src/lib/chipobject') {
        into '/linux/athena/shared/'
    }
    from ('RequiredVersion.txt') {
        into '/'
    }
}

task libZipDebug(type: Zip) {
    destinationDir = outputsFolder
    baseName = zipBaseName
    classifier = "linuxathenadebug"

    from('src/lib/chipobject') {
        into '/linux/athena/shared/'
    }
    from ('RequiredVersion.txt') {
        into '/'
    }
}

task headersZip(type: Zip) {
    destinationDir = outputsFolder
    baseName = zipBaseName
    classifier = "headers"

    from('src/include/FRC_FPGA_ChipObject') {
        into '/FRC_FPGA_ChipObject'
    }

    from ('src/include/visa') {
        into '/visa'
    }
}

task netCommLib(type: Zip) {
    destinationDir = outputsFolder
    baseName = netcommZipBaseName
    classifier = "linuxathena"

    from('src/lib/netcomm') {
        into '/linux/athena/shared/'
    }
}

task netCommLibDebug(type: Zip) {
    destinationDir = outputsFolder
    baseName = netcommZipBaseName
    classifier = "linuxathenadebug"

    from('src/lib/netcomm') {
        into '/linux/athena/shared/'
    }
}

task netCommHeaders(type: Zip) {
    destinationDir = outputsFolder
    baseName = netcommZipBaseName
    classifier = "headers"

    from('src/include/FRC_NetworkCommunication') {
        into '/FRC_NetworkCommunication'
    }
}

build.dependsOn netCommLib
build.dependsOn headersZip
build.dependsOn netCommHeaders
build.dependsOn libZip
build.dependsOn libZipDebug
build.dependsOn netCommLibDebug

addTaskToCopyAllOutputs(netCommLib)
addTaskToCopyAllOutputs(headersZip)
addTaskToCopyAllOutputs(libZip)
addTaskToCopyAllOutputs(netCommHeaders)
addTaskToCopyAllOutputs(libZipDebug)
addTaskToCopyAllOutputs(netCommLibDebug)

publishing {
    publications {
        chipobject(MavenPublication) {
            artifact libZip
            artifact headersZip
            artifact libZipDebug

            artifactId = "${baseArtifactId}"
            groupId artifactGroupId
            version pubVersion
        }
        netcomm(MavenPublication) {
            artifact netCommLib
            artifact netCommHeaders
            artifact netCommLibDebug

            artifactId = "${netcommBaseArtifactId}"
            groupId artifactGroupId
            version pubVersion
        }
    }
}

task patchNiLibraries() {
    doLast {
        // Patch ChipObject headers to be self contained
        FileTree chipTree = fileTree(dir: "$rootDir/src/include/FRC_FPGA_ChipObject/nRoboRIO_FPGANamespace")
        chipTree.each { File file ->
            String contents = file.getText('UTF-8')
            contents = contents.replaceAll('#include \"tSystemInterface.h\"', '#include \"../tSystem.h\"\n#include \"../tSystemInterface.h\"')
            file.write(contents, 'UTF-8')
        }

        // Patch NetComm headers to work on Windows
        FileTree netTree = fileTree(dir: "$rootDir/src/include/FRC_NetworkCommunication")
        netTree.each { File file ->
            String contents = file.getText('UTF-8')
            contents = contents.replaceAll('#ifdef WIN32', '#ifdef _WIN32')
            contents = contents.replaceAll('# include <vxWorks_compat.h>', '#include <windows.h>')
            contents = contents.replaceAll('#include <vxWorks_compat.h>', '#include <windows.h>')
            file.write(contents, 'UTF-8')
        }

        FileTree allTree = fileTree(dir: "$rootDir/src/include/")
        allTree.each { File file ->
            String contents = file.getText('UTF-8')
            contents = contents.replaceAll('\r\n', '\n')
            file.write(contents, 'UTF-8')
        }
    }
}

wrapper {
  gradleVersion = '5.4.1'
}
